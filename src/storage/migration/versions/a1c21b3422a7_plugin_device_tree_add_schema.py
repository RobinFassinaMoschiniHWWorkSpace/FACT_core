"""plugin_device_tree_add_schema

Revision ID: a1c21b3422a7
Revises: 221cfef47173
Create Date: 2023-04-24 11:18:50.037043

"""
from alembic import op
import sqlalchemy as sa
from alembic import context

from sqlalchemy.dialects.postgresql import ARRAY, CHAR, JSONB, VARCHAR
from sqlalchemy.ext.mutable import MutableDict, MutableList


# revision identifiers, used by Alembic.
revision = 'a1c21b3422a7'
down_revision = '221cfef47173'
branch_labels = None
depends_on = None

# The version we downgrade to
PLUGIN_OLD_VERSION = "1.0"
# The version we upgrade to
PLUGIN_NEW_VERSION = "2.0.0"
# All versions (with possibly all different schemas) we can upgrade from
PLUGIN_UPGRADALBE_VERSIONS = [PLUGIN_OLD_VERSION]
PLUGIN = "device_tree"


# References https://stackoverflow.com/questions/43153346/update-column-content-during-alembic-migration
def upgrade() -> None:
    connection = context.get_bind()

    # Define the table
    # XXX Should this maybe be dynamically generated by reflection?
    analysis_table = sa.Table(
        "analysis",
        sa.MetaData(),
        sa.Column("uid", VARCHAR(78)),
        sa.Column("plugin", VARCHAR(64)),
        sa.Column("plugin_version", VARCHAR(16)),
        sa.Column("result", MutableDict.as_mutable(JSONB), default={}),
    )

    a = connection.execute(
        sa.select([analysis_table.c.uid, analysis_table.c.result,],).where(
            analysis_table.c.plugin == PLUGIN,
            analysis_table.c.plugin_version.in_(PLUGIN_UPGRADALBE_VERSIONS),
        ),
    ).fetchall()

    for uid, old_result in a:
        new_result = {"result": old_result}
        connection.execute(
            analysis_table.update().where(
                analysis_table.c.uid == uid,
                analysis_table.c.plugin == PLUGIN,
            ).values(
                result=new_result,
                plugin_version=PLUGIN_NEW_VERSION,
            )
        )


def downgrade() -> None:
    connection = context.get_bind()

    # Define the table
    # XXX Should this maybe be dynamically generated by reflection?
    analysis_table = sa.Table(
        "analysis",
        sa.MetaData(),
        sa.Column("uid", VARCHAR(78)),
        sa.Column("plugin", VARCHAR(64)),
        sa.Column("plugin_version", VARCHAR(16)),
        sa.Column("result", MutableDict.as_mutable(JSONB), default={}),
    )

    a = connection.execute(
        sa.select([analysis_table.c.uid, analysis_table.c.plugin, analysis_table.c.result,],).where(
            analysis_table.c.plugin == "device_tree",
            analysis_table.c.plugin_version == PLUGIN_NEW_VERSION,
        ),
    ).fetchall()

    for uid, plugin, new_result in a:
        old_result = new_result.pop("result")
        connection.execute(
            analysis_table.update().where(
                analysis_table.c.uid == uid,
                analysis_table.c.plugin == plugin,
            ).values(
                result=old_result,
                plugin_version=PLUGIN_OLD_VERSION,
            )
        )
